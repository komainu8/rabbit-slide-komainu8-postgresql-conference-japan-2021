= PGroongaを使って\n全文検索結果を\nより良くする方法

 : author
    堀本 泰弘
 : institution
    株式会社クリアコード
 : content-source
    PostgreSQL Conference Japan 2021
 : date
    2021-11-12
 : allotted-time
    45m
 : start-time
    2021-11-12T16:10:00+09:00
 : end-time
    2021-11-12T16:55:00+09:00
 : theme
    .

= 自己紹介

  # image
  # src = images/self-introduction.png
  # relative_height = 107

= 今日のテーマ

PGroongaで\n検索結果を((*より良く*))しよう！

= 今日のテーマ

...の前に

= PGroongaとは？

PGroonga?\n
(ぴーじーるんが)

= PGroongaとは？

PostgreSQLで\n((*高速・高機能な*))全文検索を実現\nする拡張

= PGroongaの特徴

(1) 簡単に使える
(2) 速い
(3) ((*高機能*))

= 今日のテーマ

今日は特に\n
((*高機能*))\n
に注目します！

= 全文検索結果の改善

PGroongaで検索は速くなった😁

= 全文検索

でも、検索結果がいまいち。。。😞

= 検索結果の良し悪し

そもそも\n((*検索結果が悪い*))とは？

= 検索結果の良し悪し

検索漏れがある😞

= 検索結果の良し悪し

ノイズが多い\n😞

= 検索結果の良し悪し

有用な情報を\n探し出せない\n😞

= 適合率と再現率

適合率と再現率

= 適合率？

* 検索結果の中にどれだけ正解が含まれるか。
* 適合率↑ノイズ↓

= 再現率？

* 検索キーワードに関連するレコードの中からどれだけ検索にヒットするか。
* 再現率↑検索漏れ↓

= 適合率と再現率

* 適合率と再現率はトレードオフ
* 適合率↑再現率↓
* 再現率↑適合率↓

= ランキング

検索結果の表示順

= ランキング

ユーザーは\n((*上位数件*))\nしか見ない

= ランキング

すごくほしい情報があっても\n30件目にあったら((*見ない*))

= ランキング

ほしそうな情報を上位に持ってこれるかも大事

= PGroongaで検索結果の改善

PGroongaで適合率、再現率、ランキングを改善！

= 適合率と再現率の改良

具体的には以下の機能を使う

* ノーマライザー
* トークナイザー
* スコアラー

= ノーマライザー

何ができるのか？

= ノーマライザー

同一視

= ノーマライザー

例えば、

* "㌕"と"キログラム"
* "きろぐらむ"と"キログラム"
* "ｷﾛｸﾞﾗﾑ"と"キログラム"

= ノーマライザー

検索キーワード："キログラム"

* "㌕" ((*HIT*))
* "きろぐらむ" ((*HIT*))
* "ｷﾛｸﾞﾗﾑ" ((*HIT*))

となってほしい

= ノーマライザー

ノーマライザーを使う

= ノーマライザー

以下を全部同じものとして扱う\n(同一視する)

* "キログラム"
* "㌕"
* "きろぐらむ"
* "ｷﾛｸﾞﾗﾑ"

= ノーマライザー

PGroongaで\nノーマライザー？

= ノーマライザー

まずは、デフォルトで実行

  # coderay sql

    CREATE DATABASE pgroonga_test;
    CREATE EXTENSION pgroonga;
    CREATE TABLE normalizer_test (
      id integer,
      content text
    );
    CREATE INDEX pgroonga_content_index ON normalizer_test USING pgroonga (content);

    INSERT INTO normalizer_test VALUES (1, 'キログラム');
    INSERT INTO normalizer_test VALUES (2, 'きろぐらむ');
    INSERT INTO normalizer_test VALUES (3, '㌕');
    INSERT INTO normalizer_test VALUES (4, 'ｷﾛｸﾞﾗﾑ');
    INSERT INTO normalizer_test VALUES (5, 'kiroguramu');
    INSERT INTO normalizer_test VALUES (6, 'ｋｉｒｏｇｕｒａｍｕ');

    SELECT * FROM normalizer_test WHERE content &@ 'キログラム';

= ノーマライザー

結果

  # RT
  delimiter = [|]

  id | content

  1 | キログラム
  3 | ㌕
  4 | ｷﾛｸﾞﾗﾑ

= ノーマライザー

デフォルトだと

* 半角/全角を同一視
* ㌕とキログラムを同一視

= ノーマライザー

PGroongaはデフォルトでNFKCを使った正規化を行う
(対象のテキストのエンコードがUTF-8の時)

= ノーマライザー

以下はヒットしない。

* 'きろぐらむ'
* 'kiroguramu'
* 'ｋｉｒｏｇｕｒａｍｕ'

= ノーマライザー

再現率を上げたい

= ノーマライザー

ノーマライザーを変えてみる

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130');

= ノーマライザー

結果

  # RT
  delimiter = [|]

  id | content

  1 | キログラム
  3 | ㌕
  4 | ｷﾛｸﾞﾗﾑ

= ノーマライザー

変わらない。。。

= ノーマライザー

どちらもNFKCを使った正規化なので結果同じ

* デフォルトのノーマライザー
* NormalizerNFKC130

= ノーマライザー

違い

* NormalizerNFKC130はオプションをつかって((*挙動を変更*))できる！

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130("unify_kana", true)');

= ノーマライザー

結果

  # RT
  delimiter = [|]

  id | content

  1 | キログラム
  2 | きろぐらむ
  3 | ㌕
  4 | ｷﾛｸﾞﾗﾑ

= ノーマライザー

新たに\n
'きろぐらむ'\n
がヒット

= ノーマライザー

何をしたのか？

= ノーマライザー

* unify_kana

  * ひらがなとカタカナを同一視\n(e.g.「あ」と「ア」を同一視)

= ノーマライザー

unify_kanaで\n
「きろぐらむ」\n
がヒットする

= ノーマライザー

* 「kiroguramu」
* 「'ｋｉｒｏｇｕｒａｍｕ'」

をヒットさせるには？

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130("unify_to_romaji", true)');

= ノーマライザー

結果

  # RT
  delimiter = [|]

  id | content

  1 | キログラム
  2 | きろぐらむ
  3 | ㌕
  4 | ｷﾛｸﾞﾗﾑ

= ノーマライザー

  # RT
  delimiter = [|]

  id | content

  5 | kiroguramu
  6 | ｋｉｒｏｇｕｒａｍｕ

= ノーマライザー

Complate!

= ノーマライザー

何をしたのか？

= ノーマライザー

* Unify_to_romaji

  * ローマ字に正規化\nローマ字で読んだときに同じ語は同一視する
  * (e.g. 「kiroguramu」と「きろぐらむ」を同一視。ローマ字読みが同じだから)

= ノーマライザー

ただ、2,5,6はノイズの可能性が高い。

= その他のオプション

* unify_kana_case：拗音と促音を同一視
* unify_kana_voiced_sound_mark：濁点、半濁点を同一視
* unify_hyphen：ハイフンを同一視
* unify_prolonged_sound_mark：長音記号を同一視
* unify_hyphen_and_prolonged_sound_mark：ハイフンと長音記号を同一視
* unify_middle_dot：中点を同一視
* unify_katakana_v_sounds：ヴァヴィヴヴェヴォをバビブベボに正規化
* unify_katakana_bu_sound：ヴァヴィヴヴェヴォをブに正規化
* remove_blank：空白文字を除去
* remove_new_line：改行文字を除去

= ノーマライザー

たくさんありますね！

= トークナイザー

次は、トークナイザー

= トークナイザー

何ができるのか？

= トークナイザー

トークナイザーはデータをトークンという単位に区切る

= トークナイザー

例えば、

This is a pen
-> Th / hi / is / s  /  i / is / s  /  a / a  /  p / pe / en / n

= トークナイザー

これはペンです
-> これ / れは / はペ / ペン / ンで / です / す
= トークナイザー

検索キーワードも同様にトークンに区切る。

= トークナイザー

検索キーワード:pen
pen -> pe / en / n

= トークナイザー

データの中に pe / en / n がこの順序ででてくるデータを取得する。

= トークナイザー

トークナイザーによって、適合率も再現率も変わる。

= トークナイザー

適合率を上げてみる

= トークナイザー

  # coderay sql

    CREATE TABLE tokenizer_test (
      title text
    );
    CREATE INDEX pgroonga_content_index ON tokenizer_test USING pgroonga (title);

    INSERT INTO tokenizer_test VALUES ('京都府 1日目 金閣寺');
    INSERT INTO tokenizer_test VALUES ('京都府 2日目 嵐山');
    INSERT INTO tokenizer_test VALUES ('京都府 3日目 天橋立');
    INSERT INTO tokenizer_test VALUES ('東京都 1日目 スカイツリー');
    INSERT INTO tokenizer_test VALUES ('東京都 2日目 浅草寺');
    INSERT INTO tokenizer_test VALUES ('北海道 1日目 函館');
    INSERT INTO tokenizer_test VALUES ('北海道 2日目 トマム');
    INSERT INTO tokenizer_test VALUES ('北海道 3日目 富良野');
    INSERT INTO tokenizer_test VALUES ('北海道 4日目 美瑛');
    INSERT INTO tokenizer_test VALUES ('北海道 5日目 旭川');

    SELECT * FROM tokenizer_test WHERE title &@ '京都';

= トークナイザー

結果

= トークナイザー

  # coderay sql

                    title                 
    --------------------------------------
     京都府 1日目 金閣寺
     京都府 2日目 嵐山
     京都府 3日目 天橋立
     東京都 1日目 スカイツリー
     東京都 2日目 浅草寺
    (5 rows)

= トークナイザー

"東京都"がヒットする。。。

= トークナイザー

なぜ？

= トークナイザー

東京都 -> 東京 / ((*京都*)) / 都
京都府 -> 京都 / 都府 / 府

= トークナイザー

再現率を上げる

= トークナイザー

東京都のレコードはノイズなのでヒットしてほしくない

= トークナイザー

トークナイザーを変える

= トークナイザー

  # coderay sql

    CREATE INDEX pgroonga_content_index ON tokenizer_test USING pgroonga (title) WITH (tokenizer='TokenMecab');

= トークナイザー

結果

= トークナイザー

        title        
---------------------
 京都府 1日目 金閣寺
 京都府 2日目 嵐山
 京都府 3日目 天橋立
(3 rows)

= トークナイザー

他にも
* TokenBigram
* TokenBigramIgnoreBlank
* TokenBigramIgnoreBlankSplitSymbol
* TokenBigramIgnoreBlankSplitSymbolAlpha
* TokenBigramIgnoreBlankSplitSymbolAlphaDigit
* TokenBigramSplitSymbol
* TokenBigramSplitSymbolAlpha
* TokenBigramSplitSymbolAlphaFigit
* TokenDelimit
* TokenDelimitNull
* TokenNgram
* TokenPattern
* TokenRegexp
* TokenTable
* TokenTrigram
* TokenUnigram

= ステミング

語形変化

= ステミング

意味は同じで形が変わるもの。

名詞の語形変化は曲用
動詞の語形変化は活用

= ステミング

例えば

develop, developped, developing

のように、原形、過去形、進行形と意味は同じで
形が変わるもの。

= ステミング

develop, developped, developing
を
develop のみでヒットさせたい

= ステミング

ステミング(語幹処理)

= ステミング

語幹=単語の変化しない部分
develop, developped, developing
なら develop が語幹

= ステミング

曲用や活用で語形変化した語を語幹に変換する
つまり
develop, developped, developing
を
developに変換する

= ステミング

語幹となる語で検索すれば、活用、曲用後の語も検索できる

= ステミング

PGroongaではどうするのか？

= ステミング

トークンフィルター

= ステミング

トークナイズされたトークンを加工できる

= ステミング

  # coderay sql

    CREATE TABLE steming_test (
      title text
    );
    CREATE INDEX pgroonga_content_index ON steming_test USING pgroonga (title);

    INSERT INTO tokenizer_test VALUES ('I develop Groonga');
    INSERT INTO tokenizer_test VALUES ('I am developing Groonga');
    INSERT INTO tokenizer_test VALUES ('I developed Groonga');

    SELECT * FROM tokenizer_test WHERE title &@ 'develop';

= ステミング

  # coderay sql

       title       
-------------------
 I develop Groonga
(1 row)

= ステミング

  # coderay sql

    CREATE INDEX pgroonga_content_index ON steming_test USING pgroonga (title) WITH (plugins='token_filters/stem', token_filters='TokenFilterStem');

= ステミング

          title          
-------------------------
 I develop Groonga
 I am developing Groonga
 I developed Groonga
(3 rows)

= ストップワード

頻出語。文書中のどこにでもでてくる語。
and, is 日本語だと 、や。

= ストップワード

文書中のどこにでもでてくる文字が検索キーワードに含まれていると、必要のない情報がヒットしやすい

= ストップワード

再現率が下がる

= ストップワード

ストップワードを除去することで再現率を上げる

= ストップワード

何をストップワードとするかは一概に決定できない

= ストップワード

PGroongaは、自分でストップワードを登録できる

= 同義語展開

意味が同じで、言葉が違う。
「牛乳」と「ミルク」等

= 同義語展開

意味が同じならヒットしてほしい

= 読みがな検索

異体字、送り仮名の違い

= 読みがな検索

「広」と「廣」
「焼肉」と「焼き肉」

= fuzzy検索

typo
「テクノロジー」と「テノクロジー」

= スコアリング

検索結果順を決める

= スコアリング

何を元に「それっぽい」と判断するのか

= スコアリング

* TF(PGroongaのデフォルト)
* TF-IDF

= スコアリング

何を元に「それっぽい」と判断するのか

= スコアリング

TF

単語の出現数。
検索キーワードがより多く含まれているレコードのスコアーが高くなる

高速

= スコアリング

TF-IDF

単語の出現数 * 単語のレア度

検索キーワードがより多く含まれていて、検索キーワードがレアな単語だと
スコアーが高くなる。

TFに比べて低速

= まとめ

PGroongaを使って、検索結果を改善できました！

= 参考資料

= 参考

* PGroonga自体の解説

  * ((<URL:https://www.slideshare.net/kou/postgresql-conference-japan-2017>))

= 参考

* PHPのマニュアル検索
  * ((<URL:https://www.slideshare.net/kou/phpconference2017>))

* Redmineのチケットを検索
  * ((<URL:https://www.slideshare.net/kou/redminetokyo12>))
  * ((<URL:https://github.com/clear-code/redmine_full_text_search>))

= 参考

* AWSでPGroongaを使う
  * ((<URL:https://slide.rabbit-shocker.org/authors/komainu8/postgresql-conference-japan-2019/>))
