= PGroongaを使って\n全文検索結果を\nより良くする方法

 : author
    堀本 泰弘
 : institution
    株式会社クリアコード
 : content-source
    PostgreSQL Conference Japan 2021
 : date
    2021-11-12
 : allotted-time
    45m
 : start-time
    2021-11-12T16:10:00+09:00
 : end-time
    2021-11-12T16:55:00+09:00
 : theme
    .

= 自己紹介

  # image
  # src = images/self-introduction.png
  # relative_height = 107

= 今日のテーマ

PGroongaの機能を使って\n検索結果を((*より良く*))しよう！

= 今日のテーマ

...の前に

= PGroongaとは？

PGroonga?\n
(ぴーじーるんが)

= PGroongaとは？

PostgreSQLで\n((*高速・高機能な*))全文検索を実現\nする拡張

= PGroongaの特徴

(1) ((*簡単*))に使える
(2) ((*速い*))
(3) ((*高機能*))

= 今日のテーマ

今日は特に\n
((*高機能*))\n
に注目します！

= 全文検索結果

PGroongaを使って、検索は速くなった、検索結果もそれなりに良い

= 全文検索

でも、特定の状況下では、検索結果がいまいち

= 検索結果の良し悪し

そもそも、検索結果の良い/悪いとはどういうことか？

= 適合率と再現率

適合率

= 適合率と再現率

再現率

= 適合率？

検索結果の中でどれだけ正解が含まれるか。

= 再現率？

正解の中からどれだけ検索にヒットするか。

= 適合率と再現率

適合率と再現率はトレードオフ

= ランキング

適合率、再現率も大事だが、検索結果の表示順も大事

= ランキング

なぜ？

= ランキング

通常ユーザーは上位数件しか見ない。

= ランキング

ユーザーがすごくほしい情報がヒットしていても、その情報が結果の100件目に現れていたらユーザーの目に止まらない。

= ランキング

ユーザーがほしそうな情報を上位に持ってこれるかも大事

= PGroongaで検索結果の改善

PGroongaの機能で適合率、再現率、ランキングを改良する！

= 適合率と再現率の改良

ノーマライザー

= ノーマライザー

何ができるのか？

= ノーマライザー

同一視

= ノーマライザー

例えば、

* "㌕"と"キログラム"
* "きろぐらむ"と"キログラム"
* "ｷﾛｸﾞﾗﾑ"と"キログラム"

= ノーマライザー

"キログラム"で"㌕"も"きろぐらむ"も"ｷﾛｸﾞﾗﾑ"もヒットしてほしい！

= ノーマライザー

ノーマライザーを使うことで、
"キログラム"で"㌕"も"きろぐらむ"も"ｷﾛｸﾞﾗﾑ"もヒットする。

= ノーマライザー

以下を全部同じものとして扱う(同一視する)から

* "キログラム"
* "㌕"
* "きろぐらむ"
* "ｷﾛｸﾞﾗﾑ"

= ノーマライザー

PGroongaではどうするのか？

= ノーマライザー

  # coderay sql

    CREATE DATABASE pgroonga_test;
    CREATE EXTENSION pgroonga;
    CREATE TABLE normalizer_test (
      id integer,
      content text
    );
    CREATE INDEX pgroonga_content_index ON normalizer_test USING pgroonga (content);

    INSERT INTO normalizer_test VALUES (1, 'キログラム');
    INSERT INTO normalizer_test VALUES (2, 'きろぐらむ');
    INSERT INTO normalizer_test VALUES (3, '㌕');
    INSERT INTO normalizer_test VALUES (4, 'ｷﾛｸﾞﾗﾑ');
    INSERT INTO normalizer_test VALUES (5, 'kiroguramu');
    INSERT INTO normalizer_test VALUES (6, 'ｋｉｒｏｇｕｒａｍｕ');

    SELECT * FROM normalizer_test WHERE content &@ 'キログラム';

= ノーマライザー

結果

= ノーマライザー

  # coderay sql

     id |      content       
    ----+--------------------
      1 | キログラム
      3 | ㌕
      4 | ｷﾛｸﾞﾗﾑ
    (3 rows)

= ノーマライザー

デフォルトだと

* 半角/全角を同一視
* ㌕とキログラムを同一視

= ノーマライザー

なので、以下はヒットしない。

* 'きろぐらむ'
* 'kiroguramu'
* 'ｋｉｒｏｇｕｒａｍｕ'

= ノーマライザー

再現率を上げたい

= ノーマライザー

ノーマライザーを変えてみる

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130');

= ノーマライザー

結果

= ノーマライザー

  # coderay sql

     id |      content       
    ----+--------------------
      1 | キログラム
      3 | ㌕
      4 | ｷﾛｸﾞﾗﾑ
    (3 rows)

= ノーマライザー

変わらない。。。

= ノーマライザー

デフォルトのNormalizerAutoもNFKCを使うから

= ノーマライザー

ただ、NormalizerNFKC130はオプションをつかって挙動を変更できる

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130("unify_kana", true)');

= ノーマライザー

結果

= ノーマライザー

  # coderay sql

     id |      content       
    ----+--------------------
      1 | キログラム
      2 | きろぐらむ
      3 | ㌕
      4 | ｷﾛｸﾞﾗﾑ
    (4 rows)

= ノーマライザー

新たに、 'きろぐらむ' がヒット

= ノーマライザー

  # coderay sql

    CREATE INDEX pgroonga_content_index
              ON normalizer_test
           USING pgroonga (content)
            WITH (normalizers='NormalizerNFKC130("unify_kana", true,
                                                 "unify_to_romaji", true)');

= ノーマライザー

結果

= ノーマライザー

  # coderay sql

    id |            content             
   ----+--------------------------------
     1 | キログラム
     2 | きろぐらむ
     3 | ㌕
     4 | ｷﾛｸﾞﾗﾑ
     5 | kiroguramu
     6 | ｋｉｒｏｇｕｒａｍｕ

= ノーマライザー

Complate!

= ノーマライザー

何をしたのか？

= ノーマライザー

ポイントは以下のオプション

* unify_kana
* Unify_to_romaji

= ノーマライザー

* unify_kana

ひらがなとカタカナを同一視。
「あ」と「ア」が同じものとして扱われる。

= ノーマライザー

なので、「キログラム」で「」
ひらがなとカタカナを同一視。
「あ」と「ア」が同じものとして扱われる。

= ノーマライザー

* Unify_to_romaji

= トークナイザー

次は、トークナイザー

= トークナイザー

何ができるのか？

= トークナイザー

全文検索では、データをトークンという単位に区切る

= トークナイザー

例えば、

This is a pen
-> Th / hi / is / s  /  i / is / s  /  a / a  /  p / pe / en / n

= トークナイザー

これはペンです
-> これ / れは / はペ / ペン / ンで / です / す
= トークナイザー

検索キーワードも同様にトークンに区切る。

= トークナイザー

検索キーワード:pen
pen -> pe / en / n

= トークナイザー

データの中に pe / en / n がこの順序ででてくるデータを取得する。

= トークナイザー

トークナイザーによって、適合率も再現率も変わる。

= トークナイザー

適合率を上げてみる

= トークナイザー

  # coderay sql

    CREATE TABLE tokenizer_test (
      title text
    );
    CREATE INDEX pgroonga_content_index ON tokenizer_test USING pgroonga (title);

    INSERT INTO tokenizer_test VALUES ('京都府 1日目 金閣寺');
    INSERT INTO tokenizer_test VALUES ('京都府 2日目 嵐山');
    INSERT INTO tokenizer_test VALUES ('京都府 3日目 天橋立');
    INSERT INTO tokenizer_test VALUES ('東京都 1日目 スカイツリー');
    INSERT INTO tokenizer_test VALUES ('東京都 2日目 浅草寺');
    INSERT INTO tokenizer_test VALUES ('北海道 1日目 函館');
    INSERT INTO tokenizer_test VALUES ('北海道 2日目 トマム');
    INSERT INTO tokenizer_test VALUES ('北海道 3日目 富良野');
    INSERT INTO tokenizer_test VALUES ('北海道 4日目 美瑛');
    INSERT INTO tokenizer_test VALUES ('北海道 5日目 旭川');

    SELECT * FROM tokenizer_test WHERE title &@ '京都';

= トークナイザー

結果

= トークナイザー

  # coderay sql

                    title                 
    --------------------------------------
     京都府 1日目 金閣寺
     京都府 2日目 嵐山
     京都府 3日目 天橋立
     東京都 1日目 スカイツリー
     東京都 2日目 浅草寺
    (5 rows)

= トークナイザー

"東京都"がヒットする。。。

= トークナイザー

なぜ？

= トークナイザー

東京都 -> 東京 / ((*京都*)) / 都
京都府 -> 京都 / 都府 / 府

= トークナイザー

再現率を上げる

= トークナイザー

東京都のレコードはノイズなのでヒットしてほしくない

= トークナイザー

トークナイザーを変える

= トークナイザー

  # coderay sql

    CREATE INDEX pgroonga_content_index ON tokenizer_test USING pgroonga (title) WITH (tokenizer='TokenMecab');

= トークナイザー

結果

= トークナイザー

        title        
---------------------
 京都府 1日目 金閣寺
 京都府 2日目 嵐山
 京都府 3日目 天橋立
(3 rows)

= ステミング

語形変化

= ステミング

意味は同じで形が変わるもの。

名詞の語形変化は曲用
動詞の語形変化は活用

= ステミング

例えば

develop, developped, developing

のように、原形、過去形、進行形と意味は同じで
形が変わるもの。

= ステミング

develop, developped, developing
を
develop のみでヒットさせたい

= ステミング

ステミング(語幹処理)

= ステミング

語幹=単語の変化しない部分
develop, developped, developing
なら develop が語幹

= ステミング

曲用や活用で語形変化した語を語幹に変換する
つまり
develop, developped, developing
を
developに変換する

= ステミング

語幹となる語で検索すれば、活用、曲用後の語も検索できる

= ステミング

PGroongaではどうするのか？

= ステミング

トークンフィルター

= ステミング

トークナイズされたトークンを加工できる

= ステミング

  # coderay sql

    CREATE TABLE steming_test (
      title text
    );
    CREATE INDEX pgroonga_content_index ON steming_test USING pgroonga (title);

    INSERT INTO tokenizer_test VALUES ('I develop Groonga');
    INSERT INTO tokenizer_test VALUES ('I am developing Groonga');
    INSERT INTO tokenizer_test VALUES ('I developed Groonga');

    SELECT * FROM tokenizer_test WHERE title &@ 'develop';

= ステミング

  # coderay sql

       title       
-------------------
 I develop Groonga
(1 row)

= ステミング

  # coderay sql

    CREATE INDEX pgroonga_content_index ON steming_test USING pgroonga (title) WITH (plugins='token_filters/stem', token_filters='TokenFilterStem');

= ステミング

          title          
-------------------------
 I develop Groonga
 I am developing Groonga
 I developed Groonga
(3 rows)

= ストップワード

頻出語。文書中のどこにでもでてくる語。
and, is 日本語だと 、や。

= ストップワード

文書中のどこにでもでてくる文字が検索キーワードに含まれていると、必要のない情報がヒットしやすい

= ストップワード

再現率が下がる

= ストップワード

ストップワードを除去することで再現率を上げる

= ストップワード

何をストップワードとするかは一概に決定できない

= ストップワード

PGroongaは、自分でストップワードを登録できる

= 同義語展開

意味が同じで、言葉が違う。
「牛乳」と「ミルク」等

= 同義語展開

意味が同じならヒットしてほしい

= 読みがな検索

異体字、送り仮名の違い

= 読みがな検索

「広」と「廣」
「焼肉」と「焼き肉」

= fuzzy検索

typo
「テクノロジー」と「テノクロジー」

= スコアリング

検索結果順を決める

= スコアリング

何を元に「それっぽい」と判断するのか

= スコアリング

* TF(PGroongaのデフォルト)
* TF-IDF

= スコアリング

何を元に「それっぽい」と判断するのか

= スコアリング

TF

単語の出現数。
検索キーワードがより多く含まれているレコードのスコアーが高くなる

高速

= スコアリング

TF-IDF

単語の出現数 * 単語のレア度

検索キーワードがより多く含まれていて、検索キーワードがレアな単語だと
スコアーが高くなる。

TFに比べて低速

= まとめ

PGroongaを使って、検索結果を改善できました！

= 参考資料

= 参考

* PGroonga自体の解説

  * ((<URL:https://www.slideshare.net/kou/postgresql-conference-japan-2017>))

= 参考

* PHPのマニュアル検索
  * ((<URL:https://www.slideshare.net/kou/phpconference2017>))

* Redmineのチケットを検索
  * ((<URL:https://www.slideshare.net/kou/redminetokyo12>))
  * ((<URL:https://github.com/clear-code/redmine_full_text_search>))

= 参考

* AWSでPGroongaを使う
  * ((<URL:https://slide.rabbit-shocker.org/authors/komainu8/postgresql-conference-japan-2019/>))
